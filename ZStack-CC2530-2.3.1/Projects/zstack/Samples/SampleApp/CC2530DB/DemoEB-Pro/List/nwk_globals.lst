###############################################################################
#
# IAR C/C++ Compiler V10.20.1.5333 for 8051               19/Sep/2018  14:13:04
# Copyright 2004-2018 IAR Systems AB.
# Evaluation license - IAR Embedded Workbench for 8051, Evaluation version 10.20
#
#    Core               =  plain
#    Code model         =  banked
#    Data model         =  large
#    Calling convention =  xdata reentrant
#    Constant location  =  data_rom
#    Dptr setup         =  1,16
#                          
#    Source file        =  
#        C:\Users\Re\Documents\ZStack\ZStack-CC2530-2.3.1\Components\stack\nwk\nwk_globals.c
#    Command line       =  
#        -f C:\Users\Re\AppData\Local\Temp\EW9ADE.tmp
#        (C:\Users\Re\Documents\ZStack\ZStack-CC2530-2.3.1\Components\stack\nwk\nwk_globals.c
#        -D ZIGBEEPRO -D BUILD_ALL_DEVICES -D HOLD_AUTO_START -D LCD_SUPPORTED
#        -D HAL_UART=FALSE -lC
#        C:\Users\Re\Documents\ZStack\ZStack-CC2530-2.3.1\Projects\zstack\Samples\SampleApp\CC2530DB\DemoEB-Pro\List
#        -lA
#        C:\Users\Re\Documents\ZStack\ZStack-CC2530-2.3.1\Projects\zstack\Samples\SampleApp\CC2530DB\DemoEB-Pro\List
#        --diag_suppress Pe001,Pa010 -o
#        C:\Users\Re\Documents\ZStack\ZStack-CC2530-2.3.1\Projects\zstack\Samples\SampleApp\CC2530DB\DemoEB-Pro\Obj
#        -e --debug --core=plain --dptr=16,1 --data_model=large
#        --code_model=banked --calling_convention=xdata_reentrant
#        --place_constants=data_rom --nr_virtual_regs 16 -f
#        C:\Users\Re\Documents\ZStack\ZStack-CC2530-2.3.1\Projects\zstack\Samples\SampleApp\CC2530DB\..\..\..\Tools\CC2530DB\f8wCoord.cfg
#        (-DCPU32MHZ -DROOT=__near_func -DMAC_CFG_APP_PENDING_QUEUE=TRUE
#        -DMAC_CFG_TX_DATA_MAX=5 -DMAC_CFG_TX_MAX=8 -DMAC_CFG_RX_MAX=5
#        -DZDO_COORDINATOR -DRTR_NWK) -f
#        C:\Users\Re\Documents\ZStack\ZStack-CC2530-2.3.1\Projects\zstack\Samples\SampleApp\CC2530DB\..\..\..\Tools\CC2530DB\f8wConfig.cfg
#        (-DSECURE=0 -DZG_SECURE_DYNAMIC=0 -DREFLECTOR
#        -DDEFAULT_CHANLIST=0x00000800 -DZDAPP_CONFIG_PAN_ID=0xFFFF
#        -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MASK=0x007F
#        -DBEACON_REQUEST_DELAY=100 -DBEACON_REQ_DELAY_MASK=0x00FF
#        -DLINK_STATUS_JITTER_MASK=0x007F -DROUTE_EXPIRY_TIME=30
#        -DAPSC_ACK_WAIT_DURATION_POLLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7
#        -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3
#        -DNWK_MAX_DATA_RETRIES=2 -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9
#        -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40 -DNWK_MAX_BINDING_ENTRIES=4
#        -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01, 0x03, 0x05, 0x07,
#        0x09, 0x0B, 0x0D, 0x0F, 0x00, 0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C,
#        0x0D}" -DMAC_MAX_FRAME_SIZE=116 -DZDNWKMGR_MIN_TRANSMISSIONS=20
#        "-DCONST=const __code" -DGENERIC=__generic -DRFD_RCVC_ALWAYS_ON=FALSE
#        -DPOLL_RATE=1000 -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100
#        -DREJOIN_POLL_RATE=440) -I
#        C:\Users\Re\Documents\ZStack\ZStack-CC2530-2.3.1\Projects\zstack\Samples\SampleApp\CC2530DB\
#        -I
#        C:\Users\Re\Documents\ZStack\ZStack-CC2530-2.3.1\Projects\zstack\Samples\SampleApp\CC2530DB\..\SOURCE\
#        -I
#        C:\Users\Re\Documents\ZStack\ZStack-CC2530-2.3.1\Projects\zstack\Samples\SampleApp\CC2530DB\..\..\..\ZMAIN\TI2530DB\
#        -I
#        C:\Users\Re\Documents\ZStack\ZStack-CC2530-2.3.1\Projects\zstack\Samples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS\MT\
#        -I
#        C:\Users\Re\Documents\ZStack\ZStack-CC2530-2.3.1\Projects\zstack\Samples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS\HAL\INCLUDE\
#        -I
#        C:\Users\Re\Documents\ZStack\ZStack-CC2530-2.3.1\Projects\zstack\Samples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS\HAL\TARGET\CC2530EB\
#        -I
#        C:\Users\Re\Documents\ZStack\ZStack-CC2530-2.3.1\Projects\zstack\Samples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS\OSAL\MCU\CCSOC\
#        -I
#        C:\Users\Re\Documents\ZStack\ZStack-CC2530-2.3.1\Projects\zstack\Samples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS\OSAL\INCLUDE\
#        -I
#        C:\Users\Re\Documents\ZStack\ZStack-CC2530-2.3.1\Projects\zstack\Samples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\AF\
#        -I
#        C:\Users\Re\Documents\ZStack\ZStack-CC2530-2.3.1\Projects\zstack\Samples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\NWK\
#        -I
#        C:\Users\Re\Documents\ZStack\ZStack-CC2530-2.3.1\Projects\zstack\Samples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\SEC\
#        -I
#        C:\Users\Re\Documents\ZStack\ZStack-CC2530-2.3.1\Projects\zstack\Samples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\SAPI\
#        -I
#        C:\Users\Re\Documents\ZStack\ZStack-CC2530-2.3.1\Projects\zstack\Samples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\SYS\
#        -I
#        C:\Users\Re\Documents\ZStack\ZStack-CC2530-2.3.1\Projects\zstack\Samples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\ZDO\
#        -I
#        C:\Users\Re\Documents\ZStack\ZStack-CC2530-2.3.1\Projects\zstack\Samples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS\ZMAC\F8W\
#        -I
#        C:\Users\Re\Documents\ZStack\ZStack-CC2530-2.3.1\Projects\zstack\Samples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS\ZMAC\
#        -I
#        C:\Users\Re\Documents\ZStack\ZStack-CC2530-2.3.1\Projects\zstack\Samples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS\SERVICES\SADDR\
#        -I
#        C:\Users\Re\Documents\ZStack\ZStack-CC2530-2.3.1\Projects\zstack\Samples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS\SERVICES\SDATA\
#        -I
#        C:\Users\Re\Documents\ZStack\ZStack-CC2530-2.3.1\Projects\zstack\Samples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS\MAC\INCLUDE\
#        -I
#        C:\Users\Re\Documents\ZStack\ZStack-CC2530-2.3.1\Projects\zstack\Samples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS\MAC\HIGH_LEVEL\
#        -I
#        C:\Users\Re\Documents\ZStack\ZStack-CC2530-2.3.1\Projects\zstack\Samples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS\MAC\LOW_LEVEL\srf04\
#        -I
#        C:\Users\Re\Documents\ZStack\ZStack-CC2530-2.3.1\Projects\zstack\Samples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS\MAC\LOW_LEVEL\srf04\SINGLE_CHIP\
#        -Ohz --require_prototypes)
#    Locale             =  English_AUS.1252
#    List file          =  
#        C:\Users\Re\Documents\ZStack\ZStack-CC2530-2.3.1\Projects\zstack\Samples\SampleApp\CC2530DB\DemoEB-Pro\List\nwk_globals.lst
#    Object file        =  
#        C:\Users\Re\Documents\ZStack\ZStack-CC2530-2.3.1\Projects\zstack\Samples\SampleApp\CC2530DB\DemoEB-Pro\Obj\nwk_globals.r51
#
###############################################################################

C:\Users\Re\Documents\ZStack\ZStack-CC2530-2.3.1\Components\stack\nwk\nwk_globals.c
      1          /**************************************************************************************************
      2            Filename:       nwk_globals.c
      3            Revised:        $Date: 2010-06-17 08:41:57 -0700 (Thu, 17 Jun 2010) $
      4            Revision:       $Revision: 22772 $
      5          
      6            Description:    User definable Network Parameters.
      7          
      8          
      9            Copyright 2004-2010 Texas Instruments Incorporated. All rights reserved.
     10          
     11            IMPORTANT: Your use of this Software is limited to those specific rights
     12            granted under the terms of a software license agreement between the user
     13            who downloaded the software, his/her employer (which must be your employer)
     14            and Texas Instruments Incorporated (the "License").  You may not use this
     15            Software unless you agree to abide by the terms of the License. The License
     16            limits your use, and you acknowledge, that the Software may not be modified,
     17            copied or distributed unless embedded on a Texas Instruments microcontroller
     18            or used solely and exclusively in conjunction with a Texas Instruments radio
     19            frequency transceiver, which is integrated into your product.  Other than for
     20            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     21            works of, modify, distribute, perform, display or sell this Software and/or
     22            its documentation for any purpose.
     23          
     24            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     25            PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     26            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     27            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     28            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     29            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     30            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     31            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     32            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     33            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     34            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     35          
     36            Should you have any questions regarding your right to use this Software,
     37            contact Texas Instruments Incorporated at www.TI.com.
     38          **************************************************************************************************/
     39          
     40          /*********************************************************************
     41           * INCLUDES
     42           */
     43          #include "ZComdef.h"
     44          #include "OSAL.h"
     45          #include "AddrMgr.h"
     46          #include "AssocList.h"
     47          #include "BindingTable.h"
     48          #include "nwk_util.h"
     49          #include "nwk_globals.h"
     50          #include "APS.h"
     51          #include "ssp.h"
     52          #include "rtg.h"
     53          #include "ZDConfig.h"
     54          #include "ZGlobals.h"
     55          
     56          #if defined ( LCD_SUPPORTED )
     57            #include "OnBoard.h"
     58          #endif
     59          
     60          /* HAL */
     61          #include "hal_lcd.h"
     62          
     63          /*********************************************************************
     64           * MACROS
     65           */
     66          
     67          /*********************************************************************
     68           * CONSTANTS
     69           */
     70          
     71          // Maximums for the data buffer queue
     72          #define NWK_MAX_DATABUFS_WAITING    8     // Waiting to be sent to MAC
     73          #define NWK_MAX_DATABUFS_SCHEDULED  5     // Timed messages to be sent
     74          #define NWK_MAX_DATABUFS_CONFIRMED  5     // Held after MAC confirms
     75          #define NWK_MAX_DATABUFS_TOTAL      12    // Total number of buffers
     76          
     77          // 1-255 (0 -> 256) X RTG_TIMER_INTERVAL
     78          // A known shortcoming is that when a message is enqueued as "hold" for a
     79          // sleeping device, the timer tick may have counted down to 1, so that msg
     80          // will not be held as long as expected. If NWK_INDIRECT_MSG_TIMEOUT is set to 1
     81          // the hold time will vary randomly from 0 - CNT_RTG_TIMER ticks.
     82          // So the hold time will vary within this interval:
     83          // { (NWK_INDIRECT_MSG_TIMEOUT-1)*CNT_RTG_TIMER,
     84          //                                    NWK_INDIRECT_MSG_TIMEOUT*CNT_RTG_TIMER }
     85          #define NWK_INDIRECT_CNT_RTG_TMR    1
     86          // To hold msg for sleeping end devices for 30 secs:
     87          // #define CNT_RTG_TIMER            1
     88          // #define NWK_INDIRECT_MSG_TIMEOUT 30
     89          // To hold msg for sleeping end devices for 30 mins:
     90          // #define CNT_RTG_TIMER            60
     91          // #define NWK_INDIRECT_MSG_TIMEOUT 30
     92          // To hold msg for sleeping end devices for 30 days:
     93          // #define CNT_RTG_TIMER            60
     94          // #define NWK_INDIRECT_MSG_TIMEOUT (30 * 24 * 60)
     95          // Maximum msgs to hold per associated device.
     96          #define NWK_INDIRECT_MSG_MAX_PER    3
     97          // Maximum total msgs to hold for all associated devices.
     98          #define NWK_INDIRECT_MSG_MAX_ALL    \
     99                                      (NWK_MAX_DATABUFS_TOTAL - NWK_INDIRECT_MSG_MAX_PER)
    100          
    101          /*********************************************************************
    102           * TYPEDEFS
    103           */
    104          
    105          /*********************************************************************
    106           * NWK GLOBAL VARIABLES
    107           */
    108          
    109          // Variables for MAX list size

   \                                 In  segment CODE_C, align 1
    110          CONST uint16 gNWK_MAX_DEVICE_LIST = NWK_MAX_DEVICES;
   \                     gNWK_MAX_DEVICE_LIST:
   \   000000   1500         DW 21
    111          
    112          // Variables for MAX Sleeping End Devices

   \                                 In  segment CODE_C, align 1
    113          CONST uint8 gNWK_MAX_SLEEPING_END_DEVICES = NWK_MAX_DEVICES - NWK_MAX_ROUTERS;
   \                     gNWK_MAX_SLEEPING_END_DEVICES:
   \   000000   0F           DB 15
    114          
    115          // Variables for MAX data buffer levels

   \                                 In  segment CODE_C, align 1
    116          CONST uint8 gNWK_MAX_DATABUFS_WAITING = NWK_MAX_DATABUFS_WAITING;
   \                     gNWK_MAX_DATABUFS_WAITING:
   \   000000   08           DB 8

   \                                 In  segment CODE_C, align 1
    117          CONST uint8 gNWK_MAX_DATABUFS_SCHEDULED = NWK_MAX_DATABUFS_SCHEDULED;
   \                     gNWK_MAX_DATABUFS_SCHEDULED:
   \   000000   05           DB 5

   \                                 In  segment CODE_C, align 1
    118          CONST uint8 gNWK_MAX_DATABUFS_CONFIRMED = NWK_MAX_DATABUFS_CONFIRMED;
   \                     gNWK_MAX_DATABUFS_CONFIRMED:
   \   000000   05           DB 5

   \                                 In  segment CODE_C, align 1
    119          CONST uint8 gNWK_MAX_DATABUFS_TOTAL = NWK_MAX_DATABUFS_TOTAL;
   \                     gNWK_MAX_DATABUFS_TOTAL:
   \   000000   0C           DB 12
    120          

   \                                 In  segment CODE_C, align 1
    121          CONST uint8 gNWK_INDIRECT_CNT_RTG_TMR = NWK_INDIRECT_CNT_RTG_TMR;
   \                     gNWK_INDIRECT_CNT_RTG_TMR:
   \   000000   01           DB 1

   \                                 In  segment CODE_C, align 1
    122          CONST uint8 gNWK_INDIRECT_MSG_MAX_PER = NWK_INDIRECT_MSG_MAX_PER;
   \                     gNWK_INDIRECT_MSG_MAX_PER:
   \   000000   03           DB 3

   \                                 In  segment CODE_C, align 1
    123          CONST uint8 gNWK_INDIRECT_MSG_MAX_ALL = NWK_INDIRECT_MSG_MAX_ALL;
   \                     gNWK_INDIRECT_MSG_MAX_ALL:
   \   000000   09           DB 9
    124          
    125          // change this if using a different stack profile...
    126          // Cskip array

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    127          uint16 *Cskip;
   \                     Cskip:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
    128          
    129          #if ( STACK_PROFILE_ID == ZIGBEEPRO_PROFILE )

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    130            uint8 CskipRtrs[1] = {0};
   \                     CskipRtrs:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    131            uint8 CskipChldrn[1] = {0};
   \                     CskipChldrn:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    132          #elif ( STACK_PROFILE_ID == HOME_CONTROLS )
    133            uint8 CskipRtrs[MAX_NODE_DEPTH+1] = {6,6,6,6,6,0};
    134            uint8 CskipChldrn[MAX_NODE_DEPTH+1] = {20,20,20,20,20,0};
    135          #elif ( STACK_PROFILE_ID == GENERIC_STAR )
    136            uint8 CskipRtrs[MAX_NODE_DEPTH+1] = {5,5,5,5,5,0};
    137            uint8 CskipChldrn[MAX_NODE_DEPTH+1] = {5,5,5,5,5,0};
    138          #elif ( STACK_PROFILE_ID == NETWORK_SPECIFIC )
    139            uint8 CskipRtrs[MAX_NODE_DEPTH+1] = {5,5,5,5,5,0};
    140            uint8 CskipChldrn[MAX_NODE_DEPTH+1] = {5,5,5,5,5,0};
    141          #endif // STACK_PROFILE_ID
    142          
    143          // Minimum lqi value that is required for association

   \                                 In  segment XDATA_I, align 1, keep-with-next
    144          uint8 gMIN_TREE_LINK_COST = MIN_LQI_COST_3;
   \                     gMIN_TREE_LINK_COST:
   \   000000                DS 1
   \   000001                REQUIRE `?<Initializer for gMIN_TREE_LINK_COST>`
   \   000001                REQUIRE __INIT_XDATA_I
    145          
    146          // Statically defined Associated Device List

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    147          associated_devices_t AssociatedDevList[NWK_MAX_DEVICES];
   \                     AssociatedDevList:
   \   000000                DS 378
   \   00017A                REQUIRE __INIT_XDATA_Z
    148          

   \                                 In  segment CODE_C, align 1
    149          CONST uint16 gMAX_RTG_ENTRIES = MAX_RTG_ENTRIES;
   \                     gMAX_RTG_ENTRIES:
   \   000000   2800         DW 40

   \                                 In  segment CODE_C, align 1
    150          CONST uint16 gMAX_RTG_SRC_ENTRIES = MAX_RTG_SRC_ENTRIES;
   \                     gMAX_RTG_SRC_ENTRIES:
   \   000000   0C00         DW 12

   \                                 In  segment CODE_C, align 1
    151          CONST uint8 gMAX_RREQ_ENTRIES = MAX_RREQ_ENTRIES;
   \                     gMAX_RREQ_ENTRIES:
   \   000000   08           DB 8
    152          

   \                                 In  segment CODE_C, align 1
    153          CONST uint8 gMAX_NEIGHBOR_ENTRIES = MAX_NEIGHBOR_ENTRIES;
   \                     gMAX_NEIGHBOR_ENTRIES:
   \   000000   10           DB 16
    154          
    155           // Table of neighboring nodes (not including child nodes)

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    156          neighborEntry_t neighborTable[MAX_NEIGHBOR_ENTRIES];
   \                     neighborTable:
   \   000000                DS 368
   \   000170                REQUIRE __INIT_XDATA_Z
    157          

   \                                 In  segment CODE_C, align 1
    158          CONST uint8 gMAX_SOURCE_ROUTE = MAX_SOURCE_ROUTE;
   \                     gMAX_SOURCE_ROUTE:
   \   000000   0C           DB 12
    159          

   \                                 In  segment CODE_C, align 1
    160          CONST uint8 gMAX_BROADCAST_QUEUED = MAX_BROADCAST_QUEUED;
   \                     gMAX_BROADCAST_QUEUED:
   \   000000   0A           DB 10
    161          

   \                                 In  segment CODE_C, align 1
    162          CONST uint8 gLINK_DOWN_TRIGGER = LINK_DOWN_TRIGGER;
   \                     gLINK_DOWN_TRIGGER:
   \   000000   03           DB 3
    163          
    164          // Routing table

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    165          rtgEntry_t rtgTable[MAX_RTG_ENTRIES];
   \                     rtgTable:
   \   000000                DS 280
   \   000118                REQUIRE __INIT_XDATA_Z
    166          
    167          #if defined ( ZIGBEE_SOURCE_ROUTING )

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    168            rtgSrcEntry_t rtgSrcTable[MAX_RTG_SRC_ENTRIES];
   \                     rtgSrcTable:
   \   000000                DS 72
   \   000048                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    169            uint16 rtgSrcRelayList[MAX_SOURCE_ROUTE];
   \                     rtgSrcRelayList:
   \   000000                DS 24
   \   000018                REQUIRE __INIT_XDATA_Z
    170          #endif
    171          
    172          // Table of current RREQ packets in the network

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    173          rtDiscEntry_t rtDiscTable[MAX_RREQ_ENTRIES];
   \                     rtDiscTable:
   \   000000                DS 64
   \   000040                REQUIRE __INIT_XDATA_Z
    174          
    175          // Table of data broadcast packets currently in circulation.

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    176          bcastEntry_t bcastTable[MAX_BCAST];
   \                     bcastTable:
   \   000000                DS 72
   \   000048                REQUIRE __INIT_XDATA_Z
    177          
    178          // These 2 arrays are to be used as an array of struct { uint8, uint32 }.

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    179          uint8 bcastHoldHandle[MAX_BCAST];
   \                     bcastHoldHandle:
   \   000000                DS 9
   \   000009                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    180          uint32 bcastHoldAckMask[MAX_BCAST];
   \                     bcastHoldAckMask:
   \   000000                DS 36
   \   000024                REQUIRE __INIT_XDATA_Z
    181          

   \                                 In  segment CODE_C, align 1
    182          CONST uint8 gMAX_BCAST = MAX_BCAST;
   \                     gMAX_BCAST:
   \   000000   09           DB 9
    183          
    184          // For tree addressing, this switch allows the allocation of a
    185          // router address to an end device when end device address are
    186          // all used up.  If this option is enabled, address space
    187          // could be limited.

   \                                 In  segment CODE_C, align 1
    188          CONST uint8 gNWK_TREE_ALLOCATE_ROUTERADDR_FOR_ENDDEVICE = FALSE;
   \                     gNWK_TREE_ALLOCATE_ROUTERADDR_FOR_ENDDEVICE:
   \   000000   00           DB 0
    189          
    190          #if defined ( ZIGBEE_STOCHASTIC_ADDRESSING )
    191          // number of link status periods after the last received address conflict report
    192          // (network status command)

   \                                 In  segment CODE_C, align 1
    193          CONST uint8 gNWK_CONFLICTED_ADDR_EXPIRY_TIME = NWK_CONFLICTED_ADDR_EXPIRY_TIME;
   \                     gNWK_CONFLICTED_ADDR_EXPIRY_TIME:
   \   000000   04           DB 4
    194          #endif
    195          
    196          #if defined ( ZIGBEE_FREQ_AGILITY )

   \                                 In  segment CODE_C, align 1
    197          CONST uint8 gNWK_FREQ_AGILITY_ALL_MAC_ERRS = NWK_FREQ_AGILITY_ALL_MAC_ERRS;
   \                     gNWK_FREQ_AGILITY_ALL_MAC_ERRS:
   \   000000   00           DB 0
    198          #endif
    199          
    200          // The time limited to one MTO RReq (Concentrator Announce) in milliseconds.

   \                                 In  segment CODE_C, align 1
    201          CONST uint16 gMTO_RREQ_LIMIT_TIME = MTO_RREQ_LIMIT_TIME;
   \                     gMTO_RREQ_LIMIT_TIME:
   \   000000   E803         DW 1000
    202          
    203          // The number of seconds a MTO routing entry will last.

   \                                 In  segment CODE_C, align 1
    204          CONST uint8 gMTO_ROUTE_EXPIRY_TIME = MTO_ROUTE_EXPIRY_TIME;
   \                     gMTO_ROUTE_EXPIRY_TIME:
   \   000000   FF           DB 255
    205          
    206          // Route Discovery Request Default Radius

   \                                 In  segment CODE_C, align 1
    207          CONST uint8 gDEFAULT_ROUTE_REQUEST_RADIUS = DEFAULT_ROUTE_REQUEST_RADIUS;
   \                     gDEFAULT_ROUTE_REQUEST_RADIUS:
   \   000000   1E           DB 30
    208          
    209          // Network message radius

   \                                 In  segment CODE_C, align 1
    210          CONST uint8 gDEF_NWK_RADIUS = DEF_NWK_RADIUS;
   \                     gDEF_NWK_RADIUS:
   \   000000   1E           DB 30
    211          
    212          #if ( ZSTACK_ROUTER_BUILD )

   \                                 In  segment CODE_C, align 1
    213          CONST uint16 gLINK_STATUS_JITTER_MASK = LINK_STATUS_JITTER_MASK;
   \                     gLINK_STATUS_JITTER_MASK:
   \   000000   7F00         DW 127
    214          #endif
    215          
    216          /*********************************************************************
    217           * APS GLOBAL VARIABLES
    218           */
    219          
    220          // The Maximum number of binding records
    221          // This number is defined in BindingTable.h - change it there.

   \                                 In  segment CODE_C, align 1
    222          CONST uint16 gNWK_MAX_BINDING_ENTRIES = NWK_MAX_BINDING_ENTRIES;
   \                     gNWK_MAX_BINDING_ENTRIES:
   \   000000   0400         DW 4
    223          
    224          #if defined ( REFLECTOR )
    225            // The Maximum number of cluster IDs in a binding record
    226            // This number is defined in BindingTable.h - change it there.

   \                                 In  segment CODE_C, align 1
    227            CONST uint8 gMAX_BINDING_CLUSTER_IDS = MAX_BINDING_CLUSTER_IDS;
   \                     gMAX_BINDING_CLUSTER_IDS:
   \   000000   04           DB 4
    228          

   \                                 In  segment CODE_C, align 1
    229            CONST uint16 gBIND_REC_SIZE = sizeof( BindingEntry_t );
   \                     gBIND_REC_SIZE:
   \   000000   0E00         DW 14
    230          
    231            // Binding Table

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    232            BindingEntry_t BindingTable[NWK_MAX_BINDING_ENTRIES];
   \                     BindingTable:
   \   000000                DS 56
   \   000038                REQUIRE __INIT_XDATA_Z
    233          #endif
    234          
    235          // Maximum number allowed in the groups table.

   \                                 In  segment CODE_C, align 1
    236          CONST uint8 gAPS_MAX_GROUPS = APS_MAX_GROUPS;
   \                     gAPS_MAX_GROUPS:
   \   000000   10           DB 16
    237          
    238          // APS End Device Broadcast Table
    239          #if ( ZG_BUILD_ENDDEVICE_TYPE )

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    240            apsEndDeviceBroadcast_t apsEndDeviceBroadcastTable[APS_MAX_ENDDEVICE_BROADCAST_ENTRIES];
   \                     apsEndDeviceBroadcastTable:
   \   000000                DS 90
   \   00005A                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_I, align 1, keep-with-next
    241            uint8 gAPS_MAX_ENDDEVICE_BROADCAST_ENTRIES = APS_MAX_ENDDEVICE_BROADCAST_ENTRIES;
   \                     gAPS_MAX_ENDDEVICE_BROADCAST_ENTRIES:
   \   000000                DS 1
   \   000001                REQUIRE `?<Initializer for gAPS_MAX_ENDDEVICE_BROADCAST`
   \   000001                REQUIRE __INIT_XDATA_I
    242          #endif
    243          
    244          /*********************************************************************
    245           * SECURITY GLOBAL VARIABLES
    246           */
    247          
    248          // This is the default pre-configured key,
    249          // change this to make a unique key
    250          // SEC_KEY_LEN is defined in ssp.h.
    251          
    252          #if defined ( DEFAULT_KEY )

   \                                 In  segment CODE_C, align 1
    253          CONST uint8 defaultKey[SEC_KEY_LEN] = DEFAULT_KEY;
   \                     defaultKey:
   \   000000   01           DB 1
   \   000001   03           DB 3
   \   000002   05           DB 5
   \   000003   07           DB 7
   \   000004   09           DB 9
   \   000005   0B           DB 11
   \   000006   0D           DB 13
   \   000007   0F           DB 15
   \   000008   00           DB 0
   \   000009   02           DB 2
   \   00000A   04           DB 4
   \   00000B   06           DB 6
   \   00000C   08           DB 8
   \   00000D   0A           DB 10
   \   00000E   0C           DB 12
   \   00000F   0D           DB 13
    254          #else
    255          CONST uint8 defaultKey[SEC_KEY_LEN] =
    256          {
    257          #if defined ( APP_TP ) || defined ( APP_TP2 )
    258            // Key for ZigBee Conformance Testing
    259            0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb,
    260            0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa
    261          #else
    262            // Key for In-House Testing
    263            0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
    264            0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F
    265          #endif
    266          };
    267          #endif
    268          
    269          // This is the default pre-configured Trust Center Link key,
    270          // change this to make a unique key, SEC_KEY_LEN is defined in ssp.h.

   \                                 In  segment CODE_C, align 1
    271          CONST uint8 defaultTCLinkKey[SEC_KEY_LEN] =
   \                     defaultTCLinkKey:
   \   000000   56           DB 86
   \   000001   77           DB 119
   \   000002   77           DB 119
   \   000003   77           DB 119
   \   000004   77           DB 119
   \   000005   77           DB 119
   \   000006   77           DB 119
   \   000007   77           DB 119
   \   000008   77           DB 119
   \   000009   77           DB 119
   \   00000A   77           DB 119
   \   00000B   77           DB 119
   \   00000C   77           DB 119
   \   00000D   77           DB 119
   \   00000E   77           DB 119
   \   00000F   77           DB 119
    272          {
    273            0x56, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77,
    274            0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77
    275          };
    276          
    277          /*********************************************************************
    278           * GLOBAL VARIABLES - Statistics
    279           */
    280          
    281          #if defined ( PACKET_FILTER_STATS )
    282            uint32 apsInvalidPackets = 0;
    283            uint32 apsSecurityFailures = 0;
    284            uint32 nwkInvalidPackets = 0;
    285            uint32 nwkSecurityFailures = 0;
    286          #endif
    287          
    288          /*********************************************************************
    289           * STATUS STRINGS
    290           */
    291          #if defined ( LCD_SUPPORTED )

   \                                 In  segment XDATA_ROM_C, align 1
    292            const char PingStr[]         = "Ping Rcvd from";
   \                     PingStr:
   \   000000   50696E67     DB "Ping Rcvd from"
   \            20526376
   \            64206672
   \            6F6D00  

   \                                 In  segment XDATA_ROM_C, align 1
    293            const char AssocCnfStr[]     = "Assoc Cnf";
   \                     AssocCnfStr:
   \   000000   4173736F     DB "Assoc Cnf"
   \            6320436E
   \            6600    

   \                                 In  segment XDATA_ROM_C, align 1
    294            const char SuccessStr[]      = "Success";
   \                     SuccessStr:
   \   000000   53756363     DB "Success"
   \            65737300

   \                                 In  segment XDATA_ROM_C, align 1
    295            const char EndDeviceStr[]    = "EndDevice:";
   \                     EndDeviceStr:
   \   000000   456E6444     DB "EndDevice:"
   \            65766963
   \            653A00  

   \                                 In  segment XDATA_ROM_C, align 1
    296            const char ParentStr[]       = "Parent:";
   \                     ParentStr:
   \   000000   50617265     DB "Parent:"
   \            6E743A00

   \                                 In  segment XDATA_ROM_C, align 1
    297            const char ZigbeeCoordStr[]  = "ZigBee Coord";
   \                     ZigbeeCoordStr:
   \   000000   5A696742     DB "ZigBee Coord"
   \            65652043
   \            6F6F7264
   \            00      

   \                                 In  segment XDATA_ROM_C, align 1
    298            const char NetworkIDStr[]    = "Network ID:";
   \                     NetworkIDStr:
   \   000000   4E657477     DB "Network ID:"
   \            6F726B20
   \            49443A00

   \                                 In  segment XDATA_ROM_C, align 1
    299            const char RouterStr[]       = "Router:";
   \                     RouterStr:
   \   000000   526F7574     DB "Router:"
   \            65723A00

   \                                 In  segment XDATA_ROM_C, align 1
    300            const char OrphanRspStr[]    = "Orphan Response";
   \                     OrphanRspStr:
   \   000000   4F727068     DB "Orphan Response"
   \            616E2052
   \            6573706F
   \            6E736500

   \                                 In  segment XDATA_ROM_C, align 1
    301            const char SentStr[]         = "Sent";
   \                     SentStr:
   \   000000   53656E74     DB "Sent"
   \            00      

   \                                 In  segment XDATA_ROM_C, align 1
    302            const char FailedStr[]       = "Failed";
   \                     FailedStr:
   \   000000   4661696C     DB "Failed"
   \            656400  

   \                                 In  segment XDATA_ROM_C, align 1
    303            const char AssocRspFailStr[] = "Assoc Rsp fail";
   \                     AssocRspFailStr:
   \   000000   4173736F     DB "Assoc Rsp fail"
   \            63205273
   \            70206661
   \            696C00  

   \                                 In  segment XDATA_ROM_C, align 1
    304            const char AssocIndStr[]     = "Assoc Ind";
   \                     AssocIndStr:
   \   000000   4173736F     DB "Assoc Ind"
   \            6320496E
   \            6400    

   \                                 In  segment XDATA_ROM_C, align 1
    305            const char AssocCnfFailStr[] = "Assoc Cnf fail";
   \                     AssocCnfFailStr:
   \   000000   4173736F     DB "Assoc Cnf fail"
   \            6320436E
   \            66206661
   \            696C00  

   \                                 In  segment XDATA_ROM_C, align 1
    306            const char EnergyLevelStr[]  = "Energy Level";
   \                     EnergyLevelStr:
   \   000000   456E6572     DB "Energy Level"
   \            6779204C
   \            6576656C
   \            00      

   \                                 In  segment XDATA_ROM_C, align 1
    307            const char ScanFailedStr[]   = "Scan Failed";
   \                     ScanFailedStr:
   \   000000   5363616E     DB "Scan Failed"
   \            20466169
   \            6C656400
    308          #endif
    309          
    310          /*********************************************************************
    311           * @fn       nwk_globals_init()
    312           *
    313           * @brief
    314           *
    315           *   Initialize nwk layer globals.  These are the system defaults and
    316           *   should be changed by the user here.  The default definitions are
    317           *   defined in nwk.h or NLMEDE.h.
    318           *
    319           * @param   none
    320           *
    321           * @return  none
    322           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    323          void nwk_globals_init( void )
   \                     nwk_globals_init:
    324          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    325            AddrMgrInit( NWK_MAX_ADDRESSES );
   \   000004                ; Setup parameters for call to function AddrMgrInit
   \   000004   7A1A         MOV       R2,#0x1a
   \   000006   7B00         MOV       R3,#0x0
   \   000008   12....       LCALL     `??AddrMgrInit::?relay`; Banked call to: AddrMgrInit
    326          
    327          #if !defined ( ZIGBEE_STOCHASTIC_ADDRESSING )
    328            if ( ZSTACK_ROUTER_BUILD )
    329            {
    330              // Initialize the Cskip Table
    331              Cskip = osal_mem_alloc(sizeof(uint16) *(MAX_NODE_DEPTH+1));
    332              RTG_FillCSkipTable(CskipChldrn, CskipRtrs, MAX_NODE_DEPTH, Cskip);
    333            }
    334          #endif
    335          
    336            // To compile out the Link Status Feature, set NWK_LINK_STATUS_PERIOD
    337            // to 0 (compiler flag).
    338            if ( ZSTACK_ROUTER_BUILD && NWK_LINK_STATUS_PERIOD )
   \   00000B   90....       MOV       DPTR,#zgDeviceLogicalType
   \   00000E   E0           MOVX      A,@DPTR
   \   00000F   6004         JZ        ??nwk_globals_init_0
   \   000011   6401         XRL       A,#0x1
   \   000013   7003         JNZ       ??nwk_globals_init_1
    339            {
    340              NLME_InitLinkStatus();
   \                     ??nwk_globals_init_0:
   \   000015                ; Setup parameters for call to function NLME_InitLinkStatus
   \   000015   12....       LCALL     `??NLME_InitLinkStatus::?relay`; Banked call to: NLME_InitLinkStatus
    341            }
    342          
    343          #if defined ( ZIGBEE_FREQ_AGILITY )
    344            NwkFreqAgilityInit();
   \                     ??nwk_globals_init_1:
   \   000018                ; Setup parameters for call to function NwkFreqAgilityInit
   \   000018   12....       LCALL     `??NwkFreqAgilityInit::?relay`; Banked call to: NwkFreqAgilityInit
    345          #endif
    346          }
   \   00001B                REQUIRE ?Subroutine0
   \   00001B                ; // Fall through to label ?Subroutine0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine0:
   \   000000   D083         POP       DPH
   \   000002   D082         POP       DPL
   \   000004   02....       LJMP      ?BRET
    347          
    348          /*********************************************************************
    349           * @fn       NIB_init()
    350           *
    351           * @brief
    352           *
    353           *   Initialize attribute values in NIB
    354           *
    355           * @param   none
    356           *
    357           * @return  none
    358           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    359          void NIB_init()
   \                     NIB_init:
    360          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    361            _NIB.SequenceNum = LO_UINT16(osal_rand());
   \   000004                ; Setup parameters for call to function osal_rand
   \   000004   12....       LCALL     `??osal_rand::?relay`; Banked call to: osal_rand
   \   000007   EA           MOV       A,R2
   \   000008   90....       MOV       DPTR,#_NIB
   \   00000B   F0           MOVX      @DPTR,A
    362          
    363            _NIB.nwkProtocolVersion = ZB_PROT_VERS;
   \   00000C   90....       MOV       DPTR,#_NIB + 17
   \   00000F   7402         MOV       A,#0x2
   \   000011   F0           MOVX      @DPTR,A
    364            _NIB.MaxDepth = MAX_NODE_DEPTH;
   \   000012   90....       MOV       DPTR,#_NIB + 4
   \   000015   7414         MOV       A,#0x14
   \   000017   F0           MOVX      @DPTR,A
    365          
    366          #if ( NWK_MODE == NWK_MODE_MESH )
    367            _NIB.beaconOrder = BEACON_ORDER_NO_BEACONS;
   \   000018   90....       MOV       DPTR,#_NIB + 40
   \   00001B   740F         MOV       A,#0xf
   \   00001D   F0           MOVX      @DPTR,A
    368            _NIB.superFrameOrder = BEACON_ORDER_NO_BEACONS;
   \   00001E   A3           INC       DPTR
   \   00001F   F0           MOVX      @DPTR,A
    369          #endif
    370          
    371            // BROADCAST SETTINGS:
    372            // *******************
    373            //   Broadcast Delivery Time
    374            //     - set to multiples of 100ms
    375            //     - should be 500ms more than the retry time
    376            //       -  "retry time" = PassiveAckTimeout * (MaxBroadcastRetries + 1)
    377            //   Passive Ack Timeout
    378            //     - set to multiples of 100ms
    379            _NIB.BroadcastDeliveryTime = zgBcastDeliveryTime;
   \   000020   90....       MOV       DPTR,#zgBcastDeliveryTime
   \   000023   E0           MOVX      A,@DPTR
   \   000024   90....       MOV       DPTR,#_NIB + 7
   \   000027   F0           MOVX      @DPTR,A
    380            _NIB.PassiveAckTimeout     = zgPassiveAckTimeout;
   \   000028   90....       MOV       DPTR,#zgPassiveAckTimeout
   \   00002B   E0           MOVX      A,@DPTR
   \   00002C   90....       MOV       DPTR,#_NIB + 1
   \   00002F   F0           MOVX      @DPTR,A
    381            _NIB.MaxBroadcastRetries   = zgMaxBcastRetires;
   \   000030   90....       MOV       DPTR,#zgMaxBcastRetires
   \   000033   E0           MOVX      A,@DPTR
   \   000034   90....       MOV       DPTR,#_NIB + 2
   \   000037   F0           MOVX      @DPTR,A
    382          
    383            _NIB.ReportConstantCost = 0;
   \   000038   90....       MOV       DPTR,#_NIB + 8
   \   00003B   E4           CLR       A
   \   00003C   F0           MOVX      @DPTR,A
    384            _NIB.RouteDiscRetries = 0;
   \   00003D   A3           INC       DPTR
   \   00003E   F0           MOVX      @DPTR,A
    385            _NIB.SecureAllFrames = USE_NWK_SECURITY;
   \   00003F   90....       MOV       DPTR,#_NIB + 11
   \   000042   F0           MOVX      @DPTR,A
    386            _NIB.nwkAllFresh = NWK_ALL_FRESH;
   \   000043   90....       MOV       DPTR,#_NIB + 104
   \   000046   04           INC       A
   \   000047   F0           MOVX      @DPTR,A
    387          
    388            if ( ZG_SECURE_ENABLED )
    389            {
    390              _NIB.SecurityLevel = SECURITY_LEVEL;
    391            }
    392            else
    393            {
    394              _NIB.SecurityLevel = 0;
   \   000048   90....       MOV       DPTR,#_NIB + 12
   \   00004B   E4           CLR       A
   \   00004C   F0           MOVX      @DPTR,A
    395            }
    396          
    397          #if defined ( ZIGBEEPRO )
    398            _NIB.SymLink = FALSE;
   \   00004D   A3           INC       DPTR
   \   00004E   F0           MOVX      @DPTR,A
    399          #else
    400            _NIB.SymLink = TRUE;
    401          #endif
    402          
    403            _NIB.CapabilityFlags = ZDO_Config_Node_Descriptor.CapabilityFlags;
   \   00004F   90....       MOV       DPTR,#ZDO_Config_Node_Descriptor + 2
   \   000052   E0           MOVX      A,@DPTR
   \   000053   90....       MOV       DPTR,#_NIB + 14
   \   000056   F0           MOVX      @DPTR,A
    404          
    405            _NIB.TransactionPersistenceTime = zgIndirectMsgTimeout;
   \   000057   90....       MOV       DPTR,#zgIndirectMsgTimeout
   \   00005A   E0           MOVX      A,@DPTR
   \   00005B   90....       MOV       DPTR,#_NIB + 15
   \   00005E   F0           MOVX      @DPTR,A
   \   00005F   A3           INC       DPTR
   \   000060   E4           CLR       A
   \   000061   F0           MOVX      @DPTR,A
    406          
    407            _NIB.RouteDiscoveryTime = zgRouteDiscoveryTime;
   \   000062   90....       MOV       DPTR,#zgRouteDiscoveryTime
   \   000065   E0           MOVX      A,@DPTR
   \   000066   90....       MOV       DPTR,#_NIB + 18
   \   000069   F0           MOVX      @DPTR,A
    408            _NIB.RouteExpiryTime = zgRouteExpiryTime;
   \   00006A   90....       MOV       DPTR,#zgRouteExpiryTime
   \   00006D   E0           MOVX      A,@DPTR
   \   00006E   90....       MOV       DPTR,#_NIB + 19
   \   000071   12....       LCALL     ?Subroutine1 & 0xFFFF
    409          
    410            _NIB.nwkDevAddress = INVALID_NODE_ADDR;
    411            _NIB.nwkLogicalChannel = 0;
   \                     ??CrossCallReturnLabel_0:
   \   000074   A3           INC       DPTR
   \   000075   E4           CLR       A
   \   000076   12....       LCALL     ?Subroutine1 & 0xFFFF
    412            _NIB.nwkCoordAddress = INVALID_NODE_ADDR;
    413            osal_memset( _NIB.nwkCoordExtAddress, 0, Z_EXTADDR_LEN );
   \                     ??CrossCallReturnLabel_1:
   \   000079                ; Setup parameters for call to function osal_memset
   \   000079   7C08         MOV       R4,#0x8
   \   00007B   7D00         MOV       R5,#0x0
   \   00007D   7900         MOV       R1,#0x0
   \   00007F   7A..         MOV       R2,#(_NIB + 25) & 0xff
   \   000081   7B..         MOV       R3,#((_NIB + 25) >> 8) & 0xff
   \   000083   12....       LCALL     `??osal_memset::?relay`; Banked call to: osal_memset
    414            _NIB.nwkPanId = INVALID_NODE_ADDR;
   \   000086   90....       MOV       DPTR,#_NIB + 33
   \   000089   74FE         MOV       A,#-0x2
   \   00008B   F0           MOVX      @DPTR,A
   \   00008C   A3           INC       DPTR
   \   00008D   04           INC       A
   \   00008E   F0           MOVX      @DPTR,A
    415          
    416            osal_cpyExtAddr( _NIB.extendedPANID, zgExtendedPANID );
   \   00008F                ; Setup parameters for call to function sAddrExtCpy
   \   00008F   7C..         MOV       R4,#zgExtendedPANID & 0xff
   \   000091   7D..         MOV       R5,#(zgExtendedPANID >> 8) & 0xff
   \   000093   7A..         MOV       R2,#(_NIB + 53) & 0xff
   \   000095   7B..         MOV       R3,#((_NIB + 53) >> 8) & 0xff
   \   000097   12....       LCALL     `??sAddrExtCpy::?relay`; Banked call to: sAddrExtCpy
    417          
    418            _NIB.nwkKeyLoaded = FALSE;
   \   00009A   90....       MOV       DPTR,#_NIB + 61
   \   00009D   E4           CLR       A
   \   00009E   F0           MOVX      @DPTR,A
    419          
    420          #if defined ( ZIGBEE_STOCHASTIC_ADDRESSING )
    421            _NIB.nwkAddrAlloc  = NWK_ADDRESSING_STOCHASTIC;
   \   00009F   90....       MOV       DPTR,#_NIB + 96
   \   0000A2   7402         MOV       A,#0x2
   \   0000A4   F0           MOVX      @DPTR,A
    422            _NIB.nwkUniqueAddr = FALSE;
   \   0000A5   A3           INC       DPTR
   \   0000A6   E4           CLR       A
   \   0000A7   F0           MOVX      @DPTR,A
    423          #else
    424            _NIB.nwkAddrAlloc  = NWK_ADDRESSING_DISTRIBUTED;
    425            _NIB.nwkUniqueAddr = TRUE;
    426          #endif
    427          
    428            _NIB.nwkLinkStatusPeriod = NWK_LINK_STATUS_PERIOD;
   \   0000A8   A3           INC       DPTR
   \   0000A9   740F         MOV       A,#0xf
   \   0000AB   F0           MOVX      @DPTR,A
    429            _NIB.nwkRouterAgeLimit = NWK_ROUTE_AGE_LIMIT;
   \   0000AC   A3           INC       DPTR
   \   0000AD   7403         MOV       A,#0x3
   \   0000AF   F0           MOVX      @DPTR,A
    430          
    431            //MTO and source routing
    432            _NIB.nwkConcentratorDiscoveryTime = zgConcentratorDiscoveryTime;
   \   0000B0   90....       MOV       DPTR,#zgConcentratorDiscoveryTime
   \   0000B3   E0           MOVX      A,@DPTR
   \   0000B4   90....       MOV       DPTR,#_NIB + 102
   \   0000B7   F0           MOVX      @DPTR,A
    433            _NIB.nwkIsConcentrator = zgConcentratorEnable;
   \   0000B8   90....       MOV       DPTR,#zgConcentratorEnable
   \   0000BB   E0           MOVX      A,@DPTR
   \   0000BC   90....       MOV       DPTR,#_NIB + 101
   \   0000BF   F0           MOVX      @DPTR,A
    434            _NIB.nwkConcentratorRadius = zgConcentratorRadius;
   \   0000C0   90....       MOV       DPTR,#zgConcentratorRadius
   \   0000C3   E0           MOVX      A,@DPTR
   \   0000C4   90....       MOV       DPTR,#_NIB + 103
   \   0000C7   F0           MOVX      @DPTR,A
    435          
    436          #if defined ( ZIGBEE_MULTICAST )
    437            _NIB.nwkUseMultiCast = TRUE;
   \   0000C8   90....       MOV       DPTR,#_NIB + 100
   \   0000CB   7401         MOV       A,#0x1
   \   0000CD   F0           MOVX      @DPTR,A
    438          #else
    439            _NIB.nwkUseMultiCast = FALSE;
    440          #endif
    441            _NIB.nwkManagerAddr = 0x0000;
   \   0000CE   90....       MOV       DPTR,#_NIB + 105
   \   0000D1   E4           CLR       A
   \   0000D2   F0           MOVX      @DPTR,A
   \   0000D3   A3           INC       DPTR
   \   0000D4   F0           MOVX      @DPTR,A
    442            _NIB.nwkUpdateId = 0;
   \   0000D5   90....       MOV       DPTR,#_NIB + 109
   \   0000D8   F0           MOVX      @DPTR,A
    443            _NIB.nwkTotalTransmissions = 0;
   \   0000D9   90....       MOV       DPTR,#_NIB + 107
   \   0000DC   F0           MOVX      @DPTR,A
   \   0000DD   A3           INC       DPTR
   \   0000DE   F0           MOVX      @DPTR,A
    444          
    445            if ( ZSTACK_ROUTER_BUILD )
   \   0000DF   90....       MOV       DPTR,#zgDeviceLogicalType
   \   0000E2   E0           MOVX      A,@DPTR
   \   0000E3   6004         JZ        ??NIB_init_0
   \   0000E5   6401         XRL       A,#0x1
   \   0000E7   7003         JNZ       ??NIB_init_1
    446            {
    447          #if defined ( ZIGBEE_STOCHASTIC_ADDRESSING )
    448              NLME_InitStochasticAddressing();
   \                     ??NIB_init_0:
   \   0000E9                ; Setup parameters for call to function NLME_InitStochasticAddressing
   \   0000E9   12....       LCALL     `??NLME_InitStochasticAddressing::?relay`; Banked call to: NLME_InitStochasticAddressing
    449          #else
    450              NLME_InitTreeAddressing();
    451          #endif
    452            }
    453          }
   \                     ??NIB_init_1:
   \   0000EC   02....       LJMP      ?Subroutine0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine1:
   \   000000   F0           MOVX      @DPTR,A
   \   000001   A3           INC       DPTR
   \   000002   74FE         MOV       A,#-0x2
   \   000004   F0           MOVX      @DPTR,A
   \   000005   A3           INC       DPTR
   \   000006   04           INC       A
   \   000007   F0           MOVX      @DPTR,A
   \   000008   22           RET
    454          
    455          /*********************************************************************
    456           * @fn       nwk_Status()
    457           *
    458           * @brief
    459           *
    460           *   Status report.
    461           *
    462           * @param   statusCode
    463           * @param   statusValue
    464           *
    465           * @return  none
    466           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    467          void nwk_Status( uint16 statusCode, uint16 statusValue )
   \                     nwk_Status:
    468          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000   74F0         MOV       A,#-0x10
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 0
   \   000005   EC           MOV       A,R4
   \   000006   FE           MOV       R6,A
   \   000007   ED           MOV       A,R5
   \   000008   FF           MOV       R7,A
    469          #if defined ( LCD_SUPPORTED )
    470            switch ( statusCode )
   \   000009   8C..         MOV       ?V4,R4
   \   00000B   F5..         MOV       ?V5,A
   \   00000D   E4           CLR       A
   \   00000E   F5..         MOV       ?V6,A
   \   000010   F5..         MOV       ?V7,A
   \   000012   8A..         MOV       ?V0,R2
   \   000014   8B..         MOV       ?V1,R3
   \   000016   78..         MOV       R0,#?V0
   \   000018   12....       LCALL     ?US_SWITCH_SPARSE
   \                     `?<Jumptable for nwk_Status>_0`:
   \   00001B   0000         DW        0
   \   00001D   0900         DW        9
   \   00001F   0200         DW        2
   \   000021   ....         DW        ??nwk_Status_0
   \   000023   0300         DW        3
   \   000025   ....         DW        ??nwk_Status_1
   \   000027   0400         DW        4
   \   000029   ....         DW        ??nwk_Status_2
   \   00002B   0500         DW        5
   \   00002D   ....         DW        ??nwk_Status_3
   \   00002F   0600         DW        6
   \   000031   ....         DW        ??nwk_Status_4
   \   000033   0700         DW        7
   \   000035   ....         DW        ??nwk_Status_5
   \   000037   0110         DW        4097
   \   000039   ....         DW        ??nwk_Status_6
   \   00003B   0310         DW        4099
   \   00003D   ....         DW        ??nwk_Status_7
   \   00003F   0410         DW        4100
   \   000041   ....         DW        ??nwk_Status_8
   \   000043   ....         DW        ??nwk_Status_9
    471            {
    472              case NWK_STATUS_COORD_ADDR:
    473                if ( ZSTACK_ROUTER_BUILD )
   \                     ??nwk_Status_3:
   \   000045   90....       MOV       DPTR,#zgDeviceLogicalType
   \   000048   E0           MOVX      A,@DPTR
   \   000049   6007         JZ        ??nwk_Status_10
   \   00004B   6401         XRL       A,#0x1
   \   00004D   6003         JZ        $+5
   \   00004F   02....       LJMP      ??nwk_Status_9 & 0xFFFF
    474                {
    475                  HalLcdWriteString( (char*)ZigbeeCoordStr, HAL_LCD_LINE_1 );
   \                     ??nwk_Status_10:
   \   000052                ; Setup parameters for call to function HalLcdWriteString
   \   000052   7901         MOV       R1,#0x1
   \   000054   7A..         MOV       R2,#ZigbeeCoordStr & 0xff
   \   000056   7B..         MOV       R3,#(ZigbeeCoordStr >> 8) & 0xff
   \   000058   12....       LCALL     ?Subroutine2 & 0xFFFF
    476                  HalLcdWriteStringValue( (char*)NetworkIDStr, statusValue, 16, HAL_LCD_LINE_2 );
   \                     ??CrossCallReturnLabel_2:
   \   00005B   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   00005E   7910         MOV       R1,#0x10
   \   000060   EE           MOV       A,R6
   \   000061   FC           MOV       R4,A
   \   000062   EF           MOV       A,R7
   \   000063   FD           MOV       R5,A
   \   000064   7A..         MOV       R2,#NetworkIDStr & 0xff
   \   000066   7B..         MOV       R3,#(NetworkIDStr >> 8) & 0xff
   \   000068   12....       LCALL     `??HalLcdWriteStringValue::?relay`; Banked call to: HalLcdWriteStringValue
   \   00006B   7401         MOV       A,#0x1
   \   00006D   12....       LCALL     ?DEALLOC_XSTACK8
    477                  BuzzerControl( BUZZER_BLIP );
   \   000070                ; Setup parameters for call to function BuzzerControl
   \   000070   7902         MOV       R1,#0x2
   \   000072   12....       LCALL     `??BuzzerControl::?relay`; Banked call to: BuzzerControl
   \   000075   02....       LJMP      ??nwk_Status_9 & 0xFFFF
    478                }
    479                break;
    480          
    481              case NWK_STATUS_ROUTER_ADDR:
    482                if ( ZSTACK_ROUTER_BUILD )
   \                     ??nwk_Status_4:
   \   000078   90....       MOV       DPTR,#zgDeviceLogicalType
   \   00007B   E0           MOVX      A,@DPTR
   \   00007C   6007         JZ        ??nwk_Status_11
   \   00007E   6401         XRL       A,#0x1
   \   000080   6003         JZ        $+5
   \   000082   02....       LJMP      ??nwk_Status_9 & 0xFFFF
    483                {
    484                  HalLcdWriteStringValue( (char*)RouterStr, statusValue, 16, HAL_LCD_LINE_1 );
   \                     ??nwk_Status_11:
   \   000085                ; Setup parameters for call to function HalLcdWriteStringValue
   \   000085   75..01       MOV       ?V0,#0x1
   \   000088   78..         MOV       R0,#?V0
   \   00008A   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   00008D   7910         MOV       R1,#0x10
   \   00008F   7A..         MOV       R2,#RouterStr & 0xff
   \   000091   7B..         MOV       R3,#(RouterStr >> 8) & 0xff
   \   000093   8059         SJMP      ??nwk_Status_12
    485                }
    486                break;
    487          
    488              case NWK_STATUS_ORPHAN_RSP:
    489                if ( ZSTACK_ROUTER_BUILD )
   \                     ??nwk_Status_5:
   \   000095   90....       MOV       DPTR,#zgDeviceLogicalType
   \   000098   E0           MOVX      A,@DPTR
   \   000099   6007         JZ        ??nwk_Status_13
   \   00009B   6401         XRL       A,#0x1
   \   00009D   6003         JZ        $+5
   \   00009F   02....       LJMP      ??nwk_Status_9 & 0xFFFF
    490                {
    491                  if ( statusValue == ZSuccess )
   \                     ??nwk_Status_13:
   \   0000A2   7A..         MOV       R2,#OrphanRspStr & 0xff
   \   0000A4   7B..         MOV       R3,#(OrphanRspStr >> 8) & 0xff
   \   0000A6   EC           MOV       A,R4
   \   0000A7   4F           ORL       A,R7
   \   0000A8   7006         JNZ       ??nwk_Status_14
    492                    HalLcdWriteScreen( (char*)OrphanRspStr, (char*)SentStr );
   \   0000AA                ; Setup parameters for call to function HalLcdWriteScreen
   \   0000AA   7C..         MOV       R4,#SentStr & 0xff
   \   0000AC   7D..         MOV       R5,#(SentStr >> 8) & 0xff
   \   0000AE   8075         SJMP      ??nwk_Status_15
    493                  else
    494                    HalLcdWriteScreen( (char*)OrphanRspStr, (char*)FailedStr );
   \                     ??nwk_Status_14:
   \   0000B0                ; Setup parameters for call to function HalLcdWriteScreen
   \   0000B0   7C..         MOV       R4,#FailedStr & 0xff
   \   0000B2   7D..         MOV       R5,#(FailedStr >> 8) & 0xff
   \   0000B4   806F         SJMP      ??nwk_Status_15
    495                }
    496                break;
    497          
    498              case NWK_ERROR_ASSOC_RSP:
    499                if ( ZSTACK_ROUTER_BUILD )
   \                     ??nwk_Status_6:
   \   0000B6   90....       MOV       DPTR,#zgDeviceLogicalType
   \   0000B9   E0           MOVX      A,@DPTR
   \   0000BA   6004         JZ        ??nwk_Status_16
   \   0000BC   6401         XRL       A,#0x1
   \   0000BE   7068         JNZ       ??nwk_Status_9
    500                {
    501                  HalLcdWriteString( (char*)AssocRspFailStr, HAL_LCD_LINE_1 );
   \                     ??nwk_Status_16:
   \   0000C0                ; Setup parameters for call to function HalLcdWriteString
   \   0000C0   7901         MOV       R1,#0x1
   \   0000C2   7A..         MOV       R2,#AssocRspFailStr & 0xff
   \   0000C4   7B..         MOV       R3,#(AssocRspFailStr >> 8) & 0xff
   \   0000C6   803B         SJMP      ??nwk_Status_17
    502                  HalLcdWriteValue( (uint32)(statusValue), 16, HAL_LCD_LINE_2 );
    503                }
    504                break;
    505          
    506              case NWK_STATUS_ED_ADDR:
    507                if ( ZSTACK_END_DEVICE_BUILD )
   \                     ??nwk_Status_1:
   \   0000C8   90....       MOV       DPTR,#zgDeviceLogicalType
   \   0000CB   E0           MOVX      A,@DPTR
   \   0000CC   6402         XRL       A,#0x2
   \   0000CE   7058         JNZ       ??nwk_Status_9
    508                {
    509                  HalLcdWriteStringValue( (char*)EndDeviceStr, statusValue, 16, HAL_LCD_LINE_1 );
   \   0000D0                ; Setup parameters for call to function HalLcdWriteStringValue
   \   0000D0   75..01       MOV       ?V0,#0x1
   \   0000D3   78..         MOV       R0,#?V0
   \   0000D5   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0000D8   7910         MOV       R1,#0x10
   \   0000DA   7A..         MOV       R2,#EndDeviceStr & 0xff
   \   0000DC   7B..         MOV       R3,#(EndDeviceStr >> 8) & 0xff
   \   0000DE   800E         SJMP      ??nwk_Status_12
    510                }
    511                break;
    512          
    513              case NWK_STATUS_PARENT_ADDR:
    514                      HalLcdWriteStringValue( (char*)ParentStr, statusValue, 16, HAL_LCD_LINE_2 );
   \                     ??nwk_Status_2:
   \   0000E0                ; Setup parameters for call to function HalLcdWriteStringValue
   \   0000E0   75..02       MOV       ?V0,#0x2
   \   0000E3   78..         MOV       R0,#?V0
   \   0000E5   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   0000E8   7910         MOV       R1,#0x10
   \   0000EA   7A..         MOV       R2,#ParentStr & 0xff
   \   0000EC   7B..         MOV       R3,#(ParentStr >> 8) & 0xff
   \                     ??nwk_Status_12:
   \   0000EE   12....       LCALL     `??HalLcdWriteStringValue::?relay`; Banked call to: HalLcdWriteStringValue
   \   0000F1   8023         SJMP      ??nwk_Status_18
    515                break;
    516          
    517              case NWK_STATUS_ASSOC_CNF:
    518                HalLcdWriteScreen( (char*)AssocCnfStr, (char*)SuccessStr );
   \                     ??nwk_Status_0:
   \   0000F3                ; Setup parameters for call to function HalLcdWriteScreen
   \   0000F3   7C..         MOV       R4,#SuccessStr & 0xff
   \   0000F5   7D..         MOV       R5,#(SuccessStr >> 8) & 0xff
   \   0000F7   7A..         MOV       R2,#AssocCnfStr & 0xff
   \   0000F9   7B..         MOV       R3,#(AssocCnfStr >> 8) & 0xff
   \   0000FB   8028         SJMP      ??nwk_Status_15
    519                break;
    520          
    521              case NWK_ERROR_ASSOC_CNF_DENIED:
    522                HalLcdWriteString((char*)AssocCnfFailStr, HAL_LCD_LINE_1 );
   \                     ??nwk_Status_7:
   \   0000FD                ; Setup parameters for call to function HalLcdWriteString
   \   0000FD   7901         MOV       R1,#0x1
   \   0000FF   7A..         MOV       R2,#AssocCnfFailStr & 0xff
   \   000101   7B..         MOV       R3,#(AssocCnfFailStr >> 8) & 0xff
   \                     ??nwk_Status_17:
   \   000103   12....       LCALL     ?Subroutine2 & 0xFFFF
    523                HalLcdWriteValue( (uint32)(statusValue), 16, HAL_LCD_LINE_2 );
   \                     ??CrossCallReturnLabel_3:
   \   000106   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000109   7910         MOV       R1,#0x10
   \   00010B   AA..         MOV       R2,?V4
   \   00010D   AB..         MOV       R3,?V5
   \   00010F   AC..         MOV       R4,?V6
   \   000111   AD..         MOV       R5,?V7
   \   000113   12....       LCALL     `??HalLcdWriteValue::?relay`; Banked call to: HalLcdWriteValue
   \                     ??nwk_Status_18:
   \   000116   7401         MOV       A,#0x1
   \   000118   12....       LCALL     ?DEALLOC_XSTACK8
    524                break;
   \   00011B   800B         SJMP      ??nwk_Status_9
    525          
    526              case NWK_ERROR_ENERGY_SCAN_FAILED:
    527                HalLcdWriteScreen( (char*)EnergyLevelStr, (char*)ScanFailedStr );
   \                     ??nwk_Status_8:
   \   00011D                ; Setup parameters for call to function HalLcdWriteScreen
   \   00011D   7C..         MOV       R4,#ScanFailedStr & 0xff
   \   00011F   7D..         MOV       R5,#(ScanFailedStr >> 8) & 0xff
   \   000121   7A..         MOV       R2,#EnergyLevelStr & 0xff
   \   000123   7B..         MOV       R3,#(EnergyLevelStr >> 8) & 0xff
   \                     ??nwk_Status_15:
   \   000125   12....       LCALL     `??HalLcdWriteScreen::?relay`; Banked call to: HalLcdWriteScreen
    528                break;
    529            }
    530          #endif
    531          }
   \                     ??nwk_Status_9:
   \   000128   7F08         MOV       R7,#0x8
   \   00012A   02....       LJMP      ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine2:
   \   000000   12....       LCALL     `??HalLcdWriteString::?relay`; Banked call to: HalLcdWriteString
   \   000003                ; Setup parameters for call to function HalLcdWriteStringValue
   \   000003                ; Setup parameters for call to function HalLcdWriteValue
   \   000003   75..02       MOV       ?V0,#0x2
   \   000006   78..         MOV       R0,#?V0
   \   000008   22           RET
    532          
    533          /*********************************************************************
    534           * @fn       nwk_UpdateStatistics()
    535           *
    536           * @brief   Update network layer statistic counters
    537           *
    538           * @param   statisticCode
    539           *
    540           * @return  none
    541           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    542          void nwk_UpdateStatistics( uint8 statisticCode )
   \                     nwk_UpdateStatistics:
    543          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    544          #if defined ( PACKET_FILTER_STATS )
    545            switch ( statisticCode )
    546            {
    547              case STAT_NWK_INVALID_PACKET:
    548                nwkInvalidPackets++;
    549                break;
    550          
    551              case STAT_NWK_SECURITY_FAILURE:
    552                nwkInvalidPackets++;
    553                nwkSecurityFailures++;
    554                break;
    555          
    556              case STAT_APS_INVALID_PACKET:
    557                apsInvalidPackets++;
    558                break;
    559          
    560              case STAT_APS_SECURITY_FAILURE:
    561                apsSecurityFailures++;
    562                break;
    563            }
    564          #endif
    565          }
   \   000000   02....       LJMP      ?BRET

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for gMIN_TREE_LINK_COST>`:
   \   000000   06           DB 6

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for gAPS_MAX_ENDDEVICE_BROADCAST`:
   \   000000   12           DB 18

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??nwk_globals_init::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    nwk_globals_init

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??NIB_init::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    NIB_init

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??nwk_Status::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    nwk_Status

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??nwk_UpdateStatistics::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    nwk_UpdateStatistics
    566          
    567          /*********************************************************************
    568          *********************************************************************/

   Maximum stack usage in bytes:

   ISTACK XSTACK Function
   ------ ------ --------
      2      0   NIB_init
        2      0   -> NLME_InitStochasticAddressing
        2      0   -> osal_memset
        2      0   -> osal_rand
        2      0   -> sAddrExtCpy
      0     17   nwk_Status
        0     16   -> BuzzerControl
        0     16   -> HalLcdWriteScreen
        0     16   -> HalLcdWriteString
        0     17   -> HalLcdWriteStringValue
        0     17   -> HalLcdWriteValue
      0      0   nwk_UpdateStatistics
      2      0   nwk_globals_init
        2      0   -> AddrMgrInit
        2      0   -> NLME_InitLinkStatus
        2      0   -> NwkFreqAgilityInit


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       1  ?<Initializer for gAPS_MAX_ENDDEVICE_BROADCAST
       1  ?<Initializer for gMIN_TREE_LINK_COST>
       7  ?Subroutine0
       9  ?Subroutine1
       9  ?Subroutine2
      15  AssocCnfFailStr
      10  AssocCnfStr
      10  AssocIndStr
      15  AssocRspFailStr
     378  AssociatedDevList
      56  BindingTable
       2  Cskip
       1  CskipChldrn
       1  CskipRtrs
      11  EndDeviceStr
      13  EnergyLevelStr
       7  FailedStr
     239  NIB_init
       6  NIB_init::?relay
      12  NetworkIDStr
      16  OrphanRspStr
       8  ParentStr
      15  PingStr
       8  RouterStr
      12  ScanFailedStr
       5  SentStr
       8  SuccessStr
      13  ZigbeeCoordStr
      90  apsEndDeviceBroadcastTable
      36  bcastHoldAckMask
       9  bcastHoldHandle
      72  bcastTable
      16  defaultKey
      16  defaultTCLinkKey
       1  gAPS_MAX_ENDDEVICE_BROADCAST_ENTRIES
       1  gAPS_MAX_GROUPS
       2  gBIND_REC_SIZE
       1  gDEFAULT_ROUTE_REQUEST_RADIUS
       1  gDEF_NWK_RADIUS
       1  gLINK_DOWN_TRIGGER
       2  gLINK_STATUS_JITTER_MASK
       1  gMAX_BCAST
       1  gMAX_BINDING_CLUSTER_IDS
       1  gMAX_BROADCAST_QUEUED
       1  gMAX_NEIGHBOR_ENTRIES
       1  gMAX_RREQ_ENTRIES
       2  gMAX_RTG_ENTRIES
       2  gMAX_RTG_SRC_ENTRIES
       1  gMAX_SOURCE_ROUTE
       1  gMIN_TREE_LINK_COST
       1  gMTO_ROUTE_EXPIRY_TIME
       2  gMTO_RREQ_LIMIT_TIME
       1  gNWK_CONFLICTED_ADDR_EXPIRY_TIME
       1  gNWK_FREQ_AGILITY_ALL_MAC_ERRS
       1  gNWK_INDIRECT_CNT_RTG_TMR
       1  gNWK_INDIRECT_MSG_MAX_ALL
       1  gNWK_INDIRECT_MSG_MAX_PER
       2  gNWK_MAX_BINDING_ENTRIES
       1  gNWK_MAX_DATABUFS_CONFIRMED
       1  gNWK_MAX_DATABUFS_SCHEDULED
       1  gNWK_MAX_DATABUFS_TOTAL
       1  gNWK_MAX_DATABUFS_WAITING
       2  gNWK_MAX_DEVICE_LIST
       1  gNWK_MAX_SLEEPING_END_DEVICES
       1  gNWK_TREE_ALLOCATE_ROUTERADDR_FOR_ENDDEVICE
     368  neighborTable
     301  nwk_Status
       6  nwk_Status::?relay
       3  nwk_UpdateStatistics
       6  nwk_UpdateStatistics::?relay
      27  nwk_globals_init
       6  nwk_globals_init::?relay
      64  rtDiscTable
      24  rtgSrcRelayList
      72  rtgSrcTable
     280  rtgTable

 
   595 bytes in segment BANKED_CODE
    24 bytes in segment BANK_RELAYS
    68 bytes in segment CODE_C
     2 bytes in segment XDATA_I
     2 bytes in segment XDATA_ID
   178 bytes in segment XDATA_ROM_C
 1 453 bytes in segment XDATA_Z
 
    94 bytes of CODE     memory
   178 bytes of CONST    memory
   595 bytes of HUGECODE memory
 1 455 bytes of XDATA    memory

Errors: none
Warnings: none
